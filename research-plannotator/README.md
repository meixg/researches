# Plannotator Implementation Analysis

Plannotator is an interactive plan and code review tool designed specifically for AI coding agents such as **Claude Code**, **OpenCode**, and **Pi**. It provides a visual interface for users to review, annotate, and refine plans generated by these agents before they are executed.

## 1. Core Architecture

Plannotator follows a **CLI + Local Server + SPA** architecture.

- **CLI (Bun-based)**: Acts as the bridge between the AI agent and the user. It intercepts the agent's output, starts a local server, and handles the feedback loop.
- **Local Server**: A lightweight HTTP server (using `Bun.serve`) that hosts the UI and provides API endpoints for data exchange.
- **SPA (React)**: A rich, interactive web application built with React and Tailwind CSS that allows users to perform visual annotations.

### Communication Flow
1. **Interception**: The AI agent triggers a hook (e.g., `ExitPlanMode` in Claude Code) which executes the `plannotator` command, passing the plan content via `stdin`.
2. **Serving**: The CLI starts a local server (usually on a random port) and opens the user's default browser to that port.
3. **Review**: The user reviews the plan in the browser. They can highlight text to add comments, or specify insertions, deletions, and replacements.
4. **Decision**:
   - **Approve**: The UI calls `/api/approve`. The CLI then outputs a JSON decision to `stdout` telling the agent to proceed.
   - **Request Changes**: The UI calls `/api/deny` with the structured feedback. The CLI outputs a "deny" decision to `stdout` along with the feedback markdown.
5. **Iteration**: The agent receives the feedback, revises the plan, and the process repeats. Plannotator uses its **Plan Diff** engine to show what changed in the latest version.

## 2. Key Mechanisms

### Hook Interception
For Claude Code, Plannotator leverages the built-in hook system. A `PermissionRequest` hook is configured in `~/.claude/settings.json` to trigger on `ExitPlanMode`.

```json
{
  "hooks": {
    "PermissionRequest": [
      {
        "matcher": "ExitPlanMode",
        "hooks": [{ "type": "command", "command": "plannotator" }]
      }
    ]
  }
}
```

This allows Plannotator to pause the agent's execution until the user has reviewed the plan.

### Block-based Parser
Plannotator uses a custom markdown parser (`packages/ui/utils/parser.ts`) that decomposes a plan into discrete "blocks" (headings, paragraphs, code blocks, list items).
- Each block is assigned a unique ID.
- Annotations are anchored to these block IDs.
- This allows for precise, line-level feedback that is easy for the AI agent to understand when exported back as markdown.

### Feedback Export
Annotations are exported into a structured markdown format:
- **Deletions**: Shows the original text to be removed.
- **Insertions**: Shows the new text to be added.
- **Replacements**: Shows a "From/To" comparison.
- **Comments**: Provides contextual feedback on specific sections.

### Plan Diff Engine
When an agent submits a revised plan, Plannotator compares it with the previous version stored in `~/.plannotator/history/`. It uses the `diff` library to generate line-level diffs and groups adjacent changes into "modified" blocks to provide a clean "Clean Diff" view for the user.

## 3. Technology Stack

- **Runtime**: [Bun](https://bun.sh/) (chosen for its fast startup and built-in SQLite/File APIs).
- **Frontend**: [React](https://reactjs.org/), [Tailwind CSS](https://tailwindcss.com/).
- **Bundler**: [Vite](https://vitejs.dev/) (with `vite-plugin-singlefile` to embed the UI into the CLI binary).
- **Communication**: Standard `stdin`/`stdout` for agent integration; HTTP/JSON for UI-to-CLI communication.

## 4. Key Findings

- **Minimal Friction**: By using browser-based UI instead of terminal-based interaction, Plannotator provides a much higher bandwidth for plan review.
- **Agent Agnostic**: While it has specific integrations for Claude Code and OpenCode, its core `stdin` -> UI -> `stdout` loop can be adapted to almost any coding agent.
- **Enhanced Reliability**: The ability to see "what changed" (Plan Diff) after a revision significantly improves the user's confidence in the agent's iterative process.
