# Plannotator Implementation Analysis

Plannotator is an interactive plan and code review tool designed specifically for AI coding agents such as **Claude Code**, **OpenCode**, and **Pi**. It provides a visual interface for users to review, annotate, and refine plans generated by these agents before they are executed.

## 1. Core Architecture

Plannotator follows a **CLI + Local Server + SPA** architecture.

- **CLI (Bun-based)**: Acts as the bridge between the AI agent and the user. It intercepts the agent's output, starts a local server, and handles the feedback loop.
- **Local Server**: A lightweight HTTP server (using `Bun.serve`) that hosts the UI and provides API endpoints for data exchange.
- **SPA (React)**: A rich, interactive web application built with React and Tailwind CSS that allows users to perform visual annotations.

### Communication Flow
1. **Interception**: The AI agent triggers a hook (e.g., `ExitPlanMode` in Claude Code) which executes the `plannotator` command, passing the plan content via `stdin`.
2. **Serving**: The CLI starts a local server (usually on a random port) and opens the user's default browser to that port.
3. **Review**: The user reviews the plan in the browser. They can highlight text to add comments, or specify insertions, deletions, and replacements.
4. **Decision**:
   - **Approve**: The UI calls `/api/approve`. The CLI then outputs a JSON decision to `stdout` telling the agent to proceed.
   - **Request Changes**: The UI calls `/api/deny` with the structured feedback. The CLI outputs a "deny" decision to `stdout` along with the feedback markdown.
5. **Iteration**: The agent receives the feedback, revises the plan, and the process repeats. Plannotator uses its **Plan Diff** engine to show what changed in the latest version.

## 2. Key Mechanisms

### Hook Interception
For Claude Code, Plannotator leverages the built-in hook system. A `PermissionRequest` hook is configured in `~/.claude/settings.json` to trigger on `ExitPlanMode`.

```json
{
  "hooks": {
    "PermissionRequest": [
      {
        "matcher": "ExitPlanMode",
        "hooks": [{ "type": "command", "command": "plannotator" }]
      }
    ]
  }
}
```

This allows Plannotator to pause the agent's execution until the user has reviewed the plan.

### Feedback Format

Plannotator communicates with the agent via `stdout` using two main formats depending on the action.

#### A. JSON Hook Decision (e.g., for Claude Code)
When integrated as a hook, Plannotator returns a JSON object that the agent's hook system understands.

**On Approval:**
```json
{
  "hookSpecificOutput": {
    "hookEventName": "PermissionRequest",
    "decision": { "behavior": "allow" }
  }
}
```

**On Requesting Changes:**
```json
{
  "hookSpecificOutput": {
    "hookEventName": "PermissionRequest",
    "decision": {
      "behavior": "deny",
      "message": "... (Markdown Feedback Content Below) ..."
    }
  }
}
```

#### B. Structured Markdown Feedback
The feedback content (sent via `message` in JSON or directly to `stdout`) is structured to be easily parsed by the AI agent:

```markdown
# Plan Feedback

## 1. Remove this
```
text to be removed
```
> I don't want this in the plan.

## 2. Add this
```
new implementation step
```

## 3. Change this
**From:**
```
original code or step
```
**To:**
```
modified code or step
```

## 4. Feedback on: "specific phrase"
> User's specific comment about this phrase.

---
```

### Block-based Parser
Plannotator uses a custom markdown parser (`packages/ui/utils/parser.ts`) that decomposes a plan into discrete "blocks" (headings, paragraphs, code blocks, list items).
- Each block is assigned a unique ID.
- Annotations are anchored to these block IDs.
- This allows for precise, line-level feedback that is easy for the AI agent to understand when exported back as markdown.

## 3. Technology Stack

- **Runtime**: [Bun](https://bun.sh/) (chosen for its fast startup and built-in SQLite/File APIs).
- **Frontend**: [React](https://reactjs.org/), [Tailwind CSS](https://tailwindcss.com/).
- **Bundler**: [Vite](https://vitejs.dev/) (with `vite-plugin-singlefile` to embed the UI into the CLI binary).
- **Communication**: Standard `stdin`/`stdout` for agent integration; HTTP/JSON for UI-to-CLI communication.

## 4. Key Findings

- **Minimal Friction**: By using browser-based UI instead of terminal-based interaction, Plannotator provides a much higher bandwidth for plan review.
- **Agent Agnostic**: While it has specific integrations for Claude Code and OpenCode, its core `stdin` -> UI -> `stdout` loop can be adapted to almost any coding agent.
- **Enhanced Reliability**: The ability to see "what changed" (Plan Diff) after a revision significantly improves the user's confidence in the agent's iterative process.
