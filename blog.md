近期 quickjs 的作者发布了 mquickjs，在保持性能接近的情况下，内存占用大幅缩小，运行时整体内存占用只需要 100kb。

由于好奇 mquickjs 在内存和执行速度上到底怎样，我跑了一些跟 Node.js 和 QuickJS 的对比。这些测试在最近被更新了，以提供更准确的性能测量。

Node.js 作为目前最常用的运行时，在大而全的同时也有着一些自己的问题，比如启动时间长，资源占用多，V8 的 JIT 特性使得代码冷启动性能不好等等。这也使得社区出现了例如 bun、deno 等等多个运行时。严格来说 mquickjs 不是一个完整的 runtime，而是一个 engine，对标的应该是 V8。这里我们为了方便就直接跟 Node.js 来做对比了。

同时，与 QuickJS 的对比也可以看一下 mquickjs 有哪些特殊之处。

mquickjs 的使用场景主要在资源有限的嵌入式领域，或者终端设备的脚本执行等。由于自己做 SSR 的经历，本次更想要探索的是 Node.js 中这么一个场景：

- 有茫茫多的组件需要渲染：这意味着有非常多的 JS 文件，流量分布不均匀，存在大量的长尾流量。这些长尾流量在首次执行时性能不能太差，否则会导致渲染超时。
- 需要进行并行的渲染：使用线程或者进程并行渲染时，资源的占用情况会被放大，例如一个实例启动 100 个进程，内存占用就是 100 倍。

使用 Node.js 在这个场景中遇到了很多问题，那么 mquickjs 可以解决这个问题吗？之前我们尝试过 quickjs，这次看看 mquickjs 是否会有不同。

### 启动时间
测试文件：简单的 `console.log('Hello, World!')`
测量工具：Unix `time` 命令
结果：

| 运行时  | 启动时间 |
| :------- | :------- |
| Node.js  | 158ms    |
| mquickjs | 2ms      |
| QuickJS  | 3ms      |

可以看到 mquickjs 和 QuickJS 的启动速度几乎可以用”瞬时”来形容。这可能非常适合临时拉起一个实例来做任务，之后直接废弃。

当然，引擎的启动时间只是整个实例启动的一（小）部分，Node.js 中加载了很多 C++ 库的逻辑，实际使用场景中还需要加载业务逻辑代码，这些都会占用很多时间。

### SSR模拟测试（纯JS执行时间）
场景：模拟服务端渲染，1000次字符串拼接。**重要提示：此项测试已更新，现在只测量JS脚本的执行时间，排除了运行时本身的启动开销。**

| 运行时  | 执行时间 |
| :------- | :------- |
| Node.js  | 0.42ms   |
| mquickjs | 9ms      |
| QuickJS  | 0.47ms   |

这个结果与之前的测试完全不同。在排除了启动时间的影响后，我们可以看到 Node.js (V8) 和 QuickJS 在纯JS计算性能上要远远优于 mquickjs。这说明：

1.  之前的测试中，mquickjs 和 QuickJS 的优势主要来自于它们极快的启动速度。
2.  对于脚本执行本身，V8 引擎的性能优势是巨大的。QuickJS 在这个场景下也表现出了非常优秀的性能。
3.  mquickjs 在这个测试中性能最差，这可能与其内存优化策略和作为解释器的特性有关。

### 内存使用
| 场景          | Node.js     | mquickjs    | QuickJS   |
| :------------ | :---------- | :---------- | :-------- |
| 简单脚本      | 46,184 KB   | 1,664 KB    | 2,688 KB  |
| SSR模拟       | 46,700 KB   | 10,880 KB   | 2,816 KB  |
| 加载1MB文件   | 48,052 KB   | 5,452 KB    | 3,960 KB  |

可以看到 mquickjs 的内存占用确实非常少，仅为 Node.js 的**4-23%**，这使得我们可以在实例中轻松部署非常多的 mquickjs 实例。一百个实例，光运行时的内存占用就是 4.5G -> 160M 的差距。

QuickJS 的内存占用也非常低，并且在新测试中成功加载了1MB的文件，表现稳定。

但我们也可以发现，JavaScript 代码的体积是不可避免的，如果代码量非常大（我之前的业务场景），优化代码的体积也是有价值的。另外也要注意 Node.js 里除了 V8 还有很多其他 lib 代码，这些代码也是要占体积的，而如果我们想要 mquickjs 跑起来，必然也要补充这些 lib 代码，内存差异会被一定程度抹平。

### JIT 效果
V8 很快，很重要的一个原因就是可以在执行多次后进行优化，直接使用 native 代码来跑。我运行了 10 次 Mandelbrot 分形计算，观察编译器的优化效果。

**Node.js（有JIT优化）**

| 迭代次数  | 执行时间 | 性能变化         |
| :-------- | :------- | :--------------- |
| 第0次     | 217ms    | 冷启动（基线）   |
| 第1-9次(均) | ~28ms    | 性能提升约 **87%** |

首次运行非常慢（217ms），但后续运行稳定在28ms左右，性能提升了惊人的 **87%**。这是JIT编译器在运行时优化字节码的典型表现。

**mquickjs & QuickJS（无JIT，解释执行）**

| 迭代次数  | mquickjs 执行时间 (均) | QuickJS 执行时间 (均) | 性能变化 |
| :-------- | :--------------------- | :-------------------- | :------- |
| 第0-9次   | ~79ms                  | ~67ms                 | 无变化   |

所有迭代执行时间一致，无任何优化。解释执行的性能稳定但较慢。

可以看到：
- mquickjs 和 QuickJS 性能一致性强，可预测性好，但性能绝对值与优化后的 V8 差距巨大。
- 在这个场景中，QuickJS 的性能优于 mquickjs。

### 微基准测试综合对比
mquickjs 的代码中有一个 microbench 测试用例，简单的修改就可以在 Node.js 和 QuickJS 中跑起来。现在我们有了三者的对比数据。

由于每个测试的绝对时间不同，我们以 QuickJS 的总分为基准（1.0x），来对比三者的相对性能。

| 指标 (越低越好) | Node.js (V8) | mquickjs | QuickJS |
| :-------------- | :----------- | :------- | :------ |
| **总分 (相对性能)** | **0.13x**    | **0.99x**  | **1.0x**  |

*（注：总分根据各项测试的“纳秒/操作”计算得出）*

Node.js (V8) 在这个微基准测试中展现了压倒性的优势，其性能大约是 QuickJS 的 **7-8倍**，是 mquickjs 的 **7.6倍**。mquickjs 和 QuickJS 的性能则非常接近。

### 总结
在更新了更精确的测试方法后，我们可以得出更清晰的结论：
1.  **内存占用**：mquickjs 确实是三者中最低的，非常适合内存极度受限的环境。QuickJS 的内存占用也很低。
2.  **启动速度**：mquickjs 和 QuickJS 拥有近乎瞬时的启动速度，远超 Node.js。
3.  **执行性能**：一旦排除了启动时间，Node.js (V8) 的 JIT 优化带来了无与伦比的性能优势。QuickJS 的纯解释执行性能也非常出色，在某些场景下（如SSR模拟）甚至可以媲美 V8，并且全面优于 mquickjs。

总的来说，mquickjs 在内存控制上做到了极致，但牺牲了执行性能。QuickJS 则在低内存占用、快速启动和不错的执行性能之间取得了很好的平衡。而 Node.js 依然是追求极致性能和功能完备性的首选。

具体的选型还是需要看实际的使用场景。

---
对比过程中使用的脚本可以在 GitHub仓库中找到：[javascript_runtimes](https://github.com/your-repo-link-here)。
